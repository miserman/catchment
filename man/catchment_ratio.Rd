% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/catchment_ratio.R, R/catchment_weight.R
\name{catchment_ratio}
\alias{catchment_ratio}
\alias{catchment_weight}
\title{Calculate Floating Catchment Area Ratios}
\usage{
catchment_ratio(consumers = NULL, providers = NULL, cost = NULL,
  weight = NULL, normalize_weight = FALSE, scale = 2, max_cost = NULL,
  adjust_consumers = NULL, adjust_providers = NULL, adjust_zeros = 1e-06,
  return_type = "original", consumers_commutes = NULL,
  consumers_id = "GEOID", consumers_value = "count",
  consumers_location = c("X", "Y"), providers_id = "GEOID",
  providers_value = "count", providers_location = c("X", "Y"),
  distance_metric = "euclidean", verbose = FALSE)

catchment_weight(cost, weight = NULL, max_cost = NULL,
  adjust_zeros = 1e-06, scale = 2, normalize_weight = FALSE,
  verbose = FALSE)
}
\arguments{
\item{consumers}{Number of consumers (demand); either a vector with consumer amounts (such as population counts),
or a matrix-like object with a column of IDs (located by \code{consumers_id}) and a column of amounts (located by
\code{consumers_value}).}

\item{providers}{Number of providers (supply); either a vector with provider amounts (such as number of doctors),
or a matrix-like object with a column of IDs (located by \code{providers_id}) and a column of amounts (located by
\code{providers_value}).}

\item{cost}{A matrix-like object of cost associated with each pair of \code{consumers} and \code{providers}
(such as distance or travel times), with \code{consumers} in rows and \code{providers} in columns.
\code{cost}'s dimensions should be \code{c(length(consumers), length(providers))} if \code{consumers} and
\code{providers} are vectors, or will be aligned by name if available (as vector names or in \code{_id} columns).
If \code{NULL}, coordinate information will be looked for in \code{consumers} and \code{providers} (based on
\code{consumers_location} and \code{providers_location}), from which to calculate Euclidean distances.
Costs equal to \code{0} are treated as missing, so any truly \code{0} costs should be set to some minimal value.
In some cases, \code{0}s are automatically adjusted; see the \code{adjust_zeros} argument.}

\item{weight}{Means of defining catchment areas and their topology / friction / impedance. The simplest is a single
number representing a maximum distance between \code{consumers} and \code{providers} (2-step floating catchment area;
2SFCA; Luo & Wang, 2003).
An enhancement of this is a list of vectors with two values each: the first is a distance, and the second a weight
to associate with that distance (e.g., \code{list(c(10, 1), c(20, .5))}, which will give consumers within a
\code{cost} of 10 full weight, and those within a \code{cost} of 20 half weight; enhanced 2-step floating catchment
area; E2SFCA; Lou & Qi 2009). If a character, refers to a weighting function (kernel density 2-step floating
catchment area; KD2SFCA; Dai, 2010; in order from most gradual to steepest between costs of \code{1} and \code{6}):
\tabular{ll}{
  \code{linear} (\code{li}) \tab \code{{w <- (scale - cost) / scale; w[w < 0] <- 0; w}}\cr
  \code{gaussian} (\code{ga}) \tab \code{exp(-cost^2 / (2 * scale ^ 2))}\cr
  \code{d*} (name of a density function; e.g., \code{"dnorm"}) \tab
    \code{weight(cost, 0, scale)}
  \cr
  \code{p*} (name of a distribution function; e.g., \code{"pnorm"}) \tab \code{weight(-cost, 0, scale)}\cr
  \code{gravity} / \code{normal} (\code{gr} or \code{n}) \tab \code{sqrt(1 / cost^scale)}\cr
  \code{logarithmic} (\code{loga}) \tab \code{1 / (1 + log(cost, scale))}\cr
  \code{logistic} (\code{l}) \tab \code{1 / (1 + exp(scale * cost))}\cr
  \code{exponential} (\code{e}) \tab \code{exp(-cost * scale)}\cr
}
If a function, this will be passed \code{cost} as its first argument -- its output should be a matrix
convertible to a sparse matrix, of the same dimensions as \code{cost}. If a matrix-like object,
this will be converted to a sparse matrix.}

\item{normalize_weight}{Logical; if \code{TRUE}, weight is row-normalized such that \code{consumers} weights
are spread across \code{providers} in range. This can help correct for the increased weight of \code{consumers}
when they are in range of multiple \code{providers}. Selection weights like this make the difference between 2-
and 3-step floating catchment areas (3SFCA; Wan, Zou, & Sternberg, 2012).}

\item{scale}{Numeric scaling factor if \code{weight} is the name of a decay function.}

\item{max_cost}{Numeric limit on \code{cost}. This is the same as setting \code{weight} to a single value,
or specifying a list of steps as \code{weight} (where the most distant step is effectively \code{max_cost}),
although a single-value weight is exclusive (\code{cost < weight}) where steps are inclusive. This is most useful
when \code{weight} is a weighing function, where \code{max_cost} will trim the tail of the weight distribution.}

\item{adjust_consumers, adjust_providers}{A function to adjust weights when applied to \code{consumers} or
\code{providers}; should take the sparse weight matrix as its first argument, and return an adjusted matrix of the
same type. For example, you could square provider weights for the modified 2-step floating catchment area
(M2SFCA; Delamater, 2013) with \code{adjust_providers = function(w) w ^ 2}, or standardize both weights for the
balanced floating catchment area (BFCA; Paez, Higgins, & Vivona, 2019) with \code{adjust_consumers = }
\code{function(w) w / rowSums(w)} and \code{adjust_providers = function(w) sweep(w, 2, colSums(w), "/")}.
When weights are adjusted independently in this way, region scores will likely no longer sum to the sum
of \code{providers} (fewer than the total number of providers will be distributed).}

\item{adjust_zeros}{A number to set real \code{0}s to, in case \code{cost} is symmetrical and all its diagonal
values are \code{0} (assumed to be distance from self), or \code{NA}s are also present. Set to \code{FALSE}
to prevent \code{0}s from being adjusted.}

\item{return_type}{Determines the values that are returned: \code{"original"} (default) for \code{providers}
per \code{consumers} (e.g., how many, likely fractional, doctors are accessible by each person within each region),
\code{"region"} for number of \code{providers} per \code{consumers} entry (\code{consumers * original}; e.g.,
how many doctors are accessible within each region), or \code{"normalized"} for \code{original} divided by
\code{sum(region) / sum(consumers)}. Can also be a number by which to multiply the original values (e.g., \code{1000}
for \code{providers} per 1,000 \code{consumers}). Alternatively \code{"supply"} will return just the
number of resources allocated to each consumer location (total weighted resources within each consumer's catchment area),
or \code{"demand"} will return just the population per provider (total weighted population within each provider's catchment area).}

\item{consumers_commutes}{A square, consumers source x consumers origin matrix with counts of origins,
used to specify multiple possible origins for each consumer location (e.g., consumers living in location 1
may work in locations 1 and 3, so the first row of \code{consumers_commutes} should have values in columns 1 and 3).
This can also be entered in place of \code{consumers}, assuming it includes all consumers (e.g., in a worker commute
matrix, you may need to add non-workers to the diagonal, if they are also consumers).}

\item{consumers_id, consumers_value, consumers_location, providers_id, providers_value, providers_location}{Column
names in \code{consumers} and/or \code{providers} to extract IDs, values, and location data (referring to a single
\code{sf} geometry column, or multiple columns with coordinates). These can also be used to directly enter
ID, value, and/or location vectors (or matrices for location coordinates).}

\item{distance_metric}{Name of the distance metric to be used, if costs are being calculated from coordinates;
defaults to \code{"euclidean"}; see \code{\link[lingmatch]{lma_simets}}.}

\item{verbose}{Logical; if \code{TRUE}, will print logs, and the type of floating catchment area that was calculated.}
}
\value{
\code{catchment_ratio}: A vector with a ratio (determined by \code{return_type})
for each entry in \code{consumers}. If \code{return_type} is \code{"supply"}, values
will be the number of resources within the location, rather than a ratio.
If \code{return_type} is \code{"demand"}, the vector will have an entry for each provider
rather than consumer location, and values will be number of consumers.

\code{catchment_weight}: A sparse matrix of weights.
}
\description{
Calculate provider (supply) to consumer (demand) ratios within floating catchment areas.
}
\examples{
pop <- c(5, 10, 50)
doc <- c(50, 100)
travel_time <- matrix(c(5, 50, 25, 70, 40, 30), ncol = 2)

# 2-step floating catchment area
catchment_ratio(pop, doc, travel_time, 30)

# kernel density (Gaussian) 2-step floating catchment area
catchment_ratio(pop, doc, travel_time, "gaussian")

# enhanced 2-step floating catchment area
step_weights <- list(c(60, .22), c(40, .68), c(20, 1))
catchment_ratio(pop, doc, travel_time, step_weights)

# modified 2-step floating catchment area
catchment_ratio(pop, doc, travel_time, step_weights, adjust_providers = function(m) m^2)

# balanced 2-step floating catchment area
catchment_ratio(
  pop, doc, travel_time, step_weights,
  adjust_consumers = function(w) sweep(w, 1, rowSums(w), "/", FALSE),
  adjust_providers = function(w) sweep(w, 2, colSums(w), "/", FALSE),
)

# 3-step floating catchment area
catchment_ratio(pop, doc, travel_time, step_weights, normalize_weight = TRUE)

# visualized weight functions
if (require("splot", quietly = TRUE)) {
  cost <- 1:10
  scale <- 2
  splot(list(
    linear = (10 - cost) / 10,
    gaussian = exp(-cost^2 / (2 * scale^2)),
    dnorm = dnorm(cost, 0, scale),
    pnorm = pnorm(-cost, 0, scale),
    gravity = sqrt(1 / cost^scale),
    logarithmic = 1 / (1 + log(cost, scale)),
    logistic = 1 / (1 + exp(scale * cost)),
    exponential = exp(-cost * scale)
  ) ~ cost, title = "Decay Functions", laby = "Weight", labx = "Cost", lines = "con", note = FALSE)
}

# gives weight only to costs under 2
catchment_weight(matrix(c(1, 2, 1, 3, 1, 2), 3), 2)
}
\references{
Dai, D. (2010). Black residential segregation, disparities in spatial access to health care facilities, and
late-stage breast cancer diagnosis in metropolitan Detroit. \emph{Health & place, 16}, 1038-1052.
doi: \href{https://doi.org/10.1016/j.healthplace.2010.06.012}{10.1016/j.healthplace.2010.06.012}

Delamater, P. L. (2013). Spatial accessibility in suboptimally configured health care systems: a modified
two-step floating catchment area (M2SFCA) metric. \emph{Health & place, 24}, 30-43.
doi: \href{https://doi.org/10.1016/j.healthplace.2013.07.012}{10.1016/j.healthplace.2013.07.012}

Lou, W. & Qi, Y. (2009). An enhanced two-step floating catchment area (E2SFCA) method for measuring spatial
accessibility to primary care physicians. \emph{Health & Place, 15}, 1100-1107.
doi: \href{https://doi.org/10.1016/j.healthplace.2009.06.002}{10.1016/j.healthplace.2009.06.002}

Luo, W. & Wang, F. (2003). Measures of spatial accessibility to health care in a GIS environment: synthesis
and a case study in the Chicago region. \emph{Environment and Planning B: Planning and Design, 30}, 865-884.
doi: \href{https://doi.org/10.1068/b29120}{10.1068/b29120}

Paez, A., Higgins, C. D., & Vivona, S. F. (2019). Demand and level of service inflation in Floating Catchment
Area (FCA) methods. \emph{Plos one, 14}, e0218773. doi:
\href{https://doi.org/10.1371/journal.pone.0218773}{10.1371/journal.pone.0218773}

Wan, N., Zou, B., & Sternberg, T. (2012). A three-step floating catchment area method for analyzing spatial
access to health services. \emph{International Journal of Geographical Information Science, 26}, 1073-1089.
doi: \href{https://doi.org/10.1080/13658816.2011.624987}{10.1080/13658816.2011.624987}
}
