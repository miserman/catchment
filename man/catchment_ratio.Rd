% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/catchment_ratio.R
\name{catchment_ratio}
\alias{catchment_ratio}
\title{Calculate Floating Catchment Area Ratios}
\usage{
catchment_ratio(consumers, providers, cost = NULL, weight = NULL,
  normalize_weight = FALSE, scale = 2, max_cost = NULL,
  return_type = "original", consumers_id = "geoid",
  consumers_value = "count", consumers_location = "geometry",
  providers_id = "geoid", providers_value = "count",
  providers_location = "geometry", print_type = FALSE)
}
\arguments{
\item{consumers}{Number of consumers (demand); either a vector with consumer amounts (such as population counts),
or a matrix-like object with a column of IDs (located by \code{consumers_id}) and a column of amounts (located by
\code{consumers_value}).}

\item{providers}{Number of providers (supply); either a vector with provider amounts (such as number of doctors),
or a matrix-like object with a column of IDs (located by \code{providers_id}) and a column of amounts (located by
\code{providers_value}).}

\item{cost}{A matrix-like object of cost associated with each pair of \code{consumers} and \code{providers}
(such as distance or travel times), with \code{consumers} in rows and \code{providers} in columns.
\code{cost}'s dimensions should be \code{c(length(consumers), length(providers))} if \code{consumers} and
\code{providers} are vectors, or will be aligned by name if available (as vector names or in \code{_id} columns).
If \code{NULL}, coordinate information will be looked for in \code{consumers} and \code{providers} (based on
\code{consumers_location} and \code{providers_location}), from which to calculate Euclidean distances.}

\item{weight}{Means of defining catchment areas and their topology / friction. The simplest is a single number
representing a maximum distance between \code{consumers} and \code{providers} (2-step floating catchment area).
An enhancement of this is a list of vectors with two values each: the first is a distance, and the second a weight
to associate with that distance (e.g., \code{list(c(10, 1), c(20, .5))}, which will give consumers within a
\code{cost} of 10 full weight, and those within a \code{cost} of 20 half weight; enhanced 2-step floating catchment
area). If a character, refers to a weighting function (kernel density 2-step floating catchment area; in order
from most gradual to steepest between costs of \code{1} and \code{6}):
\tabular{ll}{
  \code{gaussian} (\code{ga}) \tab \code{exp(-cost^2 / (2 * scale ^ 2))}\cr
  \code{d*} (name of a density function; e.g., \code{"dnorm"}) \tab
    \code{weight(cost, 0, scale)}
  \cr
  \code{p*} (name of a distribution function; e.g., \code{"pnorm"}) \tab \code{weight(cost, 0, scale)}\cr
  \code{gravity} / \code{normal} (\code{gr} or \code{n}) \tab \code{sqrt(1 / cost^scale)}\cr
  \code{logarithmic} (\code{loga}) \tab \code{1 / (1 + log(cost, scale))}\cr
  \code{logistic} (\code{l}) \tab \code{1 / (1 + exp(scale * cost))}\cr
  \code{exponential} (\code{e}) \tab \code{exp(-cost * scale)}\cr
}
If a function, this will be passed \code{cost} as its first argument -- its output should be a matrix
convertible to a sparse matrix, of the same dimensions as \code{cost}. If a matrix-like object,
this will be converted to a sparse matrix.}

\item{normalize_weight}{Logical; if \code{TRUE}, weight is row-normalized such that \code{consumers} weights
are spread across \code{providers} in range. This can help correct for the increased weight of \code{consumers}
when they are in range of multiple \code{providers}. Selection weights like this make the difference between 2-
and 3-step floating catchment areas.}

\item{scale}{Numeric scaling factor if \code{weight} is the name of a decay function.}

\item{max_cost}{Numeric limit on \code{cost}. This is the same as setting \code{weight} to a single value,
or specifying a list of steps as \code{weight} (where the most distant step is effectively \code{max_cost}),
although a single-value weight is exclusive (\code{cost < weight}) where steps are inclusive. This is most useful
when \code{weight} is a weighing function, where \code{max_cost} will trim the tail of the weight distribution.}

\item{return_type}{Determines the values that are returned: \code{"original"} (default) for \code{providers}
per \code{consumers} (e.g., how many, likely fractional, doctors are accessible by each person within each region),
\code{"region"} for number of \code{providers} per \code{consumers} entry (\code{consumers * original}; e.g.,
how many doctors are accessible within each region), or \code{"normalized"} for \code{original} divided by
\code{sum(region) / sum(consumers)}.}

\item{consumers_id, consumers_value, consumers_location, providers_id, providers_value, providers_location}{Column
names in \code{consumers} and/or \code{providers} to extract IDs, values, and location data (referring to a single
\code{sf} geometry column, or multiple columns with coordinates).}

\item{print_type}{Logical; if \code{TRUE}, will print the type of floating catchment area that was calculated.}
}
\value{
A vector with an access score (determined by \code{return_type}) for each entry in \code{consumers}.
}
\description{
Calculate provider (supply) to consumer (demand) ratios within floating catchment areas.
}
\examples{
pop <- c(5, 10, 50)
doc <- c(50, 100)
travel_time <- matrix(c(5, 50, 25, 70, 40, 30), ncol = 2)

# 2-step floating catchment area
catchment_ratio(pop, doc, travel_time, 30)

# kernel density (Gaussian) 2-step floating catchment area
catchment_ratio(pop, doc, travel_time, "gaussian")

# enhanced 2-step floating catchment area
catchment_ratio(pop, doc, travel_time, list(c(60, .22), c(40, .68), c(20, 1)))

# 3-step floating catchment area
catchment_ratio(pop, doc, travel_time, list(c(60, .22), c(40, .68), c(20, 1)), TRUE)

# visualized weight functions
if (require("splot", quietly = TRUE)) {
  cost <- 1:10
  scale <- 2
  splot(list(
    gaussian = exp(-cost^2 / (2 * scale^2)),
    dnorm = dnorm(cost, 0, scale),
    pnorm = pnorm(-cost, 0, scale),
    gravity = sqrt(1 / cost^scale),
    logarithmic = 1 / (1 + log(cost, scale)),
    logistic = 1 / (1 + exp(scale * cost)),
    exponential = exp(-cost * scale)
  ) ~ cost, title = "Decay Functions", laby = "Weight", labx = "Cost", lines = "con", note = FALSE)
}
}
\references{
Dai, D. (2010). Black residential segregation, disparities in spatial access to health care facilities, and
late-stage breast cancer diagnosis in metropolitan Detroit. \emph{Health & place, 16}, 1038-1052.
doi: \href{https://doi.org/10.1016/j.healthplace.2010.06.012}{10.1016/j.healthplace.2010.06.012}

Lou, W. & Qi, Y. (2009). An enhanced two-step floating catchment area (E2SFCA) method for measuring spatial
accessibility to primary care physicians. \emph{Health & Place, 15}, 1100-1107.
doi: \href{https://doi.org/10.1016/j.healthplace.2009.06.002}{10.1016/j.healthplace.2009.06.002}

Luo, W. & Wang, F. (2003). Measures of spatial accessibility to health care in a GIS environment: synthesis
and a case study in the Chicago region. \emph{Environment and Planning B: Planning and Design, 30}, 865-884.
doi: \href{https://doi.org/10.1068/b29120}{10.1068/b29120}

Wan, N., Zou, B., & Sternberg, T. (2012). A three-step floating catchment area method for analyzing spatial
access to health services. \emph{International Journal of Geographical Information Science, 26}, 1073-1089.
doi: \href{https://doi.org/10.1080/13658816.2011.624987}{10.1080/13658816.2011.624987}
}
