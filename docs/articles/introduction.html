<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to Floating Catchment Areas • catchment</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Introduction to Floating Catchment Areas">
<meta property="og:description" content="catchment">
<meta property="og:image" content="/logo.svg">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">catchment</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/introduction.html">Introduction to Floating Catchment Areas</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Introduction to Floating Catchment Areas</h1>
            
      
      
      <div class="hidden name"><code>introduction.Rmd</code></div>

    </div>

    
    
<p><em>Built with R 4.1.2 on December 19 2021</em></p>
<hr>
<p><strong>Floating catchment areas</strong> can be thought of as a means of distributing consumers across providers, or allocating providers to consumers.</p>
<p><strong>Providers</strong> and <strong>consumers</strong> are locations with some quantity. At most granular, these might be individuals, such as a single doctor as provider, and single patient as consumer. In this case, each would have a quantity of 1, and if they are within range of each other, and there are no other providers or consumers in range, their floating catchment area ratio would be 1 (<code>providers / consumers</code>).</p>
<p>Usually, consumers are local groups of people, such as the population of a region (say, 1,000 people). In this case the floating catchment area ratio is <code>1 / 1000</code> – the provider distributed across consumers, resulting in the number of providers per person, or the fraction of the population with concurrent access to the provider. These ratios sum up to the number of providers when multiplied by the population: <code>1000 * 1 / 1000 == 1</code>.</p>
<p>So far, these are simple ratios, and that holds in discrete cases. <strong>Catchment areas</strong> define the range of providers, such that we can make cases discrete; that is, given a large region with many spread-out provider and consumer locations, we can define sub-regions (catchment areas) in which to calculate ratios. A catchment is the result of the provider’s catching (attracting, serving), which, when applied spatially, defines an area.</p>
<p>A simple means of defining a catchment area could be by city. Say there are two doctors in a region, but they are in different cities; it might make sense to define each doctor’s catchment area as their city, and then we have two discrete ratios to work with (each doctor divided by the population of their city). It would remain discrete to add doctors in each city, as this would simply increase the numerator of the ratio – as long as they are in the same city, they are not differentiated by this catchment area definition.</p>
<p>This might make sense in some cases, but what if the cities are close enough that the population of one might visit doctors in the other? The <strong>floating</strong> part of floating catchment areas come in when each provider location gets their own catchment area. For example, say we define each doctor’s catchment area as a range of 5 miles, rather than the city’s boundaries. This might exclude some portion of the population (those in the same city but far away), and include others (those in another city that is close), and it might result in some overlap of catchment areas between doctors.</p>
<div class="section level1">
<h1 id="basic-example">Basic Example<a class="anchor" aria-label="anchor" href="#basic-example"></a>
</h1>
<p>The most basic case where floating catchment areas differ from simple ratios is when multiple providers have differing but overlapping coverage of consumers.</p>
<p>In simpler cases, a single ratio applies equally to all consumers:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># one provider to many consumers (which are summed within the same region)</span>
<span class="va">providers</span> <span class="op">&lt;-</span> <span class="fl">1</span>
<span class="va">consumers</span> <span class="op">&lt;-</span> <span class="fl">10</span>

<span class="co">## this is a single score that applies to all consumers;</span>
<span class="co">## number of providers per consumer</span>
<span class="va">providers</span> <span class="op">/</span> <span class="va">consumers</span>
<span class="co">#&gt; [1] 0.1</span>

<span class="co"># many providers to one consumer</span>
<span class="va">providers</span> <span class="op">&lt;-</span> <span class="fl">10</span>
<span class="va">consumers</span> <span class="op">&lt;-</span> <span class="fl">1</span>

<span class="va">providers</span> <span class="op">/</span> <span class="va">consumers</span>
<span class="co">#&gt; [1] 10</span></code></pre></div>
<p>But imagine we had providers with differing consumer bases:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">providers</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>
<span class="va">consumers</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span><span class="op">)</span>

<span class="co"># here, provider 1 is in range of consumers 1 and 2,</span>
<span class="co"># and provider 2 is in range of consumers 2 and 3</span>

<span class="co">## this is represented by binary weight vectors</span>
<span class="va">in_range_p1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span>
<span class="va">in_range_p2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>

<span class="co">## this is the ratio for provider 1</span>
<span class="op">(</span><span class="va">ratio_p1</span> <span class="op">&lt;-</span> <span class="va">providers</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">in_range_p1</span> <span class="op">*</span> <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5</span>

<span class="co">## which applies to consumers 1 and 2, again represented by the weight vector</span>
<span class="op">(</span><span class="va">access_p1</span> <span class="op">&lt;-</span> <span class="va">in_range_p1</span> <span class="op">*</span> <span class="va">consumers</span> <span class="op">*</span> <span class="va">ratio_p1</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5 0.5 0.0</span>

<span class="co">## same for provider 2</span>
<span class="op">(</span><span class="va">ratio_p2</span> <span class="op">&lt;-</span> <span class="va">providers</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">in_range_p2</span> <span class="op">*</span> <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5</span>
<span class="op">(</span><span class="va">access_p2</span> <span class="op">&lt;-</span> <span class="va">in_range_p2</span> <span class="op">*</span> <span class="va">consumers</span> <span class="op">*</span> <span class="va">ratio_p2</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.0 0.5 0.5</span>

<span class="co">## and now we can combine them for individualized access scores</span>
<span class="va">access_p1</span> <span class="op">+</span> <span class="va">access_p2</span>
<span class="co">#&gt; [1] 0.5 1.0 0.5</span></code></pre></div>
<p>This introduces the concept of weights, which are the instantiation of catchment areas. In the previous example, we applied weights vector by vector manually, but an easier way to do this in bigger examples is to use a weight matrix:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># we can add both `in_range` vectors to a matrix</span>
<span class="op">(</span><span class="va">weight</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">in_range_p1</span>, <span class="va">in_range_p2</span><span class="op">)</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    1    0</span>
<span class="co">#&gt; [2,]    1    1</span>
<span class="co">#&gt; [3,]    0    1</span>

<span class="co"># then multiply and sum in one line for the same result</span>
<span class="va">weight</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">providers</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html" class="external-link">crossprod</a></span><span class="op">(</span><span class="va">weight</span>, <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;      [,1]</span>
<span class="co">#&gt; [1,]  0.5</span>
<span class="co">#&gt; [2,]  1.0</span>
<span class="co">#&gt; [3,]  0.5</span></code></pre></div>
<p>This is what the <code>catchment_ratio</code> function does:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">catchment</span><span class="op">)</span>
<span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span><span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5 1.0 0.5</span></code></pre></div>
<p>This is called a 2-step floating catchment area <span class="citation">(2SFCA; <a href="#ref-luo03" role="doc-biblioref">Luo &amp; Wang, 2003</a>)</span> because we are effectively combining catchment areas around both providers (step 1) and consumers (step 2).</p>
</div>
<div class="section level1">
<h1 id="variable-weights">Variable Weights<a class="anchor" aria-label="anchor" href="#variable-weights"></a>
</h1>
<p>Binary weight vectors denote which consumers fall within a catchment area, but they imply that all consumers fall within the catchment area to the same degree – all consumers get a weight of 1. But when providers are singular physical location which consumers must travel to, consumers might differ in distance, and this intuitively related to how well they fall into the catchment area; someone on the edge of a catchment area is not as well caught as someone nearer its center. To appreciate this difference, we can adjust weights by distance.</p>
<p>Imagine that in the previous example, consumers 1 and 2 are both close to the first provider, but on opposite sides, such that consumer 2 is just within range of the second provider, and consumer 3 is only in range of the second provider:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># say weights vary between 0 (out of range) and 1 (center of the catchment area)</span>
<span class="co">## |  Provider:     1             2</span>
<span class="co">## |  Consumer:  1     2              3</span>
<span class="co">## |            -----------------------</span>
<span class="co">## | P1 Weight: .9    .9              0</span>
<span class="co">## | P2 Weight:  0    .2             .9</span>

<span class="co">## consumers 1 and 2 are both close to provider 1</span>
<span class="va">weight_p1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">.9</span>, <span class="fl">.9</span>, <span class="fl">0</span><span class="op">)</span>

<span class="co">## consumer 2 is just in-range of provider 2, and consumer 3 is close</span>
<span class="va">weight_p2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">.2</span>, <span class="fl">.9</span><span class="op">)</span>

<span class="co"># now we can perform the same vector-wise calculations as before</span>
<span class="op">(</span><span class="va">ratio_p1</span> <span class="op">&lt;-</span> <span class="va">providers</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_p1</span> <span class="op">*</span> <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5555556</span>
<span class="op">(</span><span class="va">access_p1</span> <span class="op">&lt;-</span> <span class="va">weight_p1</span> <span class="op">*</span> <span class="va">consumers</span> <span class="op">*</span> <span class="va">ratio_p1</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5 0.5 0.0</span>

<span class="op">(</span><span class="va">ratio_p2</span> <span class="op">&lt;-</span> <span class="va">providers</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_p2</span> <span class="op">*</span> <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.9090909</span>
<span class="op">(</span><span class="va">access_p2</span> <span class="op">&lt;-</span> <span class="va">weight_p2</span> <span class="op">*</span> <span class="va">consumers</span> <span class="op">*</span> <span class="va">ratio_p2</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.0000000 0.1818182 0.8181818</span>

<span class="va">access_p1</span> <span class="op">+</span> <span class="va">access_p2</span>
<span class="co">#&gt; [1] 0.5000000 0.6818182 0.8181818</span>

<span class="co"># or use a weight matrix</span>
<span class="op">(</span><span class="va">weight</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">weight_p1</span>, <span class="va">weight_p2</span><span class="op">)</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]  0.9  0.0</span>
<span class="co">#&gt; [2,]  0.9  0.2</span>
<span class="co">#&gt; [3,]  0.0  0.9</span>
<span class="va">weight</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">providers</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html" class="external-link">crossprod</a></span><span class="op">(</span><span class="va">weight</span>, <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;           [,1]</span>
<span class="co">#&gt; [1,] 0.5000000</span>
<span class="co">#&gt; [2,] 0.6818182</span>
<span class="co">#&gt; [3,] 0.8181818</span></code></pre></div>
<p>Compared to the uniformly weighted scores, consumer 3 gets a much higher score since there is less competition from the more distant consumer 2, and consumer 2 gets a dampened score because of that distance.</p>
<p>Adjusting weights like this results in an enhanced 2-step floating catchment area <span class="citation">(E2SFCA; <a href="#ref-luo09" role="doc-biblioref">Luo &amp; Qi, 2009</a>)</span>.</p>
<p>Note that we are still just distributing providers to consumers, so access scores still sum up to the number of providers:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">consumers</span> <span class="op">*</span> <span class="va">access_p1</span> <span class="op">+</span> <span class="va">access_p2</span><span class="op">)</span>
<span class="co">#&gt; [1] 2</span></code></pre></div>
<p>Because weights are applied in both steps, or to both sides of the ratio, the absolute scale of weights is arbitrary. For example, you could multiply weights by 100 and get the same result:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span><span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span> <span class="op">*</span> <span class="fl">100</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5000000 0.6818182 0.8181818</span></code></pre></div>
</div>
<div class="section level1">
<h1 id="normalized-weights">Normalized Weights<a class="anchor" aria-label="anchor" href="#normalized-weights"></a>
</h1>
<p>An interesting way to think about weights is as probabilities that the consumer will utilize the give provider. This makes good sense with distance weighting, where, all else being equal, a consumer is less likely to make use of a distant provider if a nearer one is available.</p>
<p>Thinking of weights in this way highlights a potential issue with the way we have being applying weights: The more providers a consumer has in range, the more overall weight they get, which doesn’t make sense if consumer’s consumption is actually the same (say, each consumer is a patient visiting only one doctor).</p>
<p>To account for this, we might normalize each consumer’s weights by redistributing them:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># get each consumer's total weight</span>
<span class="op">(</span><span class="va">consumer_weight</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">weight</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.9 1.1 0.9</span>

<span class="co"># then multiply original weights by the proportion of those totals;</span>
<span class="co"># that is, each original weight gets a portion their consumer's total weight</span>
<span class="op">(</span><span class="va">weight_normed</span> <span class="op">&lt;-</span> <span class="va">weight</span> <span class="op">*</span> <span class="va">weight</span> <span class="op">/</span> <span class="va">consumer_weight</span><span class="op">)</span>
<span class="co">#&gt;           [,1]       [,2]</span>
<span class="co">#&gt; [1,] 0.9000000 0.00000000</span>
<span class="co">#&gt; [2,] 0.7363636 0.03636364</span>
<span class="co">#&gt; [3,] 0.0000000 0.90000000</span>

<span class="co"># and get the new access scores</span>
<span class="va">weight_normed</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">providers</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/crossprod.html" class="external-link">crossprod</a></span><span class="op">(</span><span class="va">weight_normed</span>, <span class="va">consumers</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;          [,1]</span>
<span class="co">#&gt; [1,] 0.550000</span>
<span class="co">#&gt; [2,] 0.488835</span>
<span class="co">#&gt; [3,] 0.961165</span>

<span class="co"># this is what the `normalize_weight` argument does</span>
<span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span><span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span>, normalize_weight <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.550000 0.488835 0.961165</span></code></pre></div>
<p>With these normalized weights, consumers 1 and 3 get higher access score because consumer 2 is now (more appropriately) spread across the 2 providers in range – consumer 1 or 3 may be the only ones using their only provider, depending on where consumer 2 goes.</p>
<p>As always, these are still just redistributions of the same number of providers:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span>
  <span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span>,
  normalize_weight <span class="op">=</span> <span class="cn">TRUE</span>, return_type <span class="op">=</span> <span class="st">"region"</span>
<span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 2</span></code></pre></div>
<p>When weights are normalized in this way, it is called a 3-step floating catchment area <span class="citation">(3SFCA; <a href="#ref-wan12" role="doc-biblioref">Wan et al., 2012</a>)</span>.</p>
<p>Note that, though the original 3-step floating catchment area used enhanced 2-step floating catchment area weights, it can be applied to any weighting scheme.</p>
<p>It is also notable that this sort of normalization might slightly over-correct – in this case, consumer 2 gets less total weight than 1 or 3. It might make more sense to give everyone a weight of 1 by using the weight proportions:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># total normed weight</span>
<span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">weight_normed</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.9000000 0.7727273 0.9000000</span>

<span class="co"># total proportional weights</span>
<span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">weight</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">weight</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 1 1 1</span>

<span class="co"># scores with weight proportions</span>
<span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span><span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">weight</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5500000 0.6038462 0.8461538</span></code></pre></div>
<p>On one hand, this appreciates that consumer 2 has access to 2 providers rather than just 1 (better access). On the other, it doesn’t appreciate that consumer 2 is always sharing providers with another consumer (worse access).</p>
</div>
<div class="section level1">
<h1 id="expanding-weights">Expanding Weights<a class="anchor" aria-label="anchor" href="#expanding-weights"></a>
</h1>
<p>The most commonly applied weights are those based on physical distance, but thinking of weights as generally describing the probability that a consumer will use a particular provider, we might imagine any number of other weight sources.</p>
<p>For example, relating to doctors and patients, health insurance networks may quite strictly condition consumer to provider pairings. Things like this can be added as weights arbitrarily:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># lets say our consumers and providers are all associated with one of two networks</span>
<span class="va">provider_networks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a"</span>, <span class="st">"b"</span><span class="op">)</span>
<span class="va">consumer_networks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"b"</span>, <span class="st">"a"</span>, <span class="st">"b"</span><span class="op">)</span>

<span class="co"># we can assign weights based on matches</span>
<span class="op">(</span><span class="va">insurance_weight</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">vapply</a></span><span class="op">(</span><span class="va">provider_networks</span>, <span class="st">'=='</span>, <span class="fu"><a href="https://rdrr.io/r/base/logical.html" class="external-link">logical</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>, <span class="va">consumer_networks</span><span class="op">)</span> <span class="op">*</span> <span class="fl">.9</span> <span class="op">+</span> <span class="fl">.1</span><span class="op">)</span>
<span class="co">#&gt;        a   b</span>
<span class="co">#&gt; [1,] 0.1 1.0</span>
<span class="co">#&gt; [2,] 1.0 0.1</span>
<span class="co">#&gt; [3,] 0.1 1.0</span>

<span class="co"># then incorporate them with our distance-based weights</span>
<span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span><span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span> <span class="op">*</span> <span class="va">insurance_weight</span>, normalize_weight <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.09274194 0.90774092 0.99951714</span></code></pre></div>
<p>With added insurance weights, consumer 1’s access score goes down quite a lot because they have no in-network providers in range.</p>
<p>Another relevant point of consumer decision might be cost versus income:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># say we had some sort of price associated with each provider</span>
<span class="va">provider_price</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">400</span>, <span class="fl">250</span><span class="op">)</span>

<span class="co"># and the monthly income of each consumer</span>
<span class="va">consumer_income</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">7</span>, <span class="fl">3</span>, <span class="fl">5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">1e4</span> <span class="op">/</span> <span class="fl">12</span>

<span class="co"># we can use this to get at a price weight --</span>
<span class="co"># the higher the proportion of monthly income their price is,</span>
<span class="co"># the less likely a consumer is to use that provider</span>
<span class="op">(</span><span class="va">monetary_cost</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">vapply</a></span><span class="op">(</span><span class="va">provider_price</span>, <span class="st">'/'</span>, <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">numeric</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>, <span class="va">consumer_income</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt;           [,1]      [,2]</span>
<span class="co">#&gt; [1,] 0.9314286 0.9571429</span>
<span class="co">#&gt; [2,] 0.8400000 0.9000000</span>
<span class="co">#&gt; [3,] 0.9040000 0.9400000</span>

<span class="co"># then incorporate that with distance weights</span>
<span class="fu"><a href="../reference/catchment_ratio.html">catchment_ratio</a></span><span class="op">(</span><span class="va">consumers</span>, <span class="va">providers</span>, weight <span class="op">=</span> <span class="va">weight</span> <span class="op">*</span> <span class="va">monetary_cost</span>, normalize_weight <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">#&gt; [1] 0.5785666 0.4607416 0.9606918</span></code></pre></div>
<p>This is a subtler weighting, but consumer 1’s score goes up a bit in particular because consumer 2 is pushed more toward provider 2 based on monetary cost, even though that travel cost is greater.</p>
<p>What information might be useful to incorporate and how much relative weight it should get are questions that will probably want to be explored on a case by case basis.</p>
</div>
<div class="section level1 unnumbered">
<h1 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h1>
<div id="refs" class="references csl-bib-body hanging-indent" line-spacing="2">
<div id="ref-luo09" class="csl-entry">
Luo, W., &amp; Qi, Y. (2009). An enhanced two-step floating catchment area (E2SFCA) method for measuring spatial accessibility to primary care physicians. <em>Health &amp; Place</em>, <em>15</em>(4), 1100–1107. <a href="https://doi.org/10.1016/j.healthplace.2009.06.002" class="external-link">https://doi.org/10.1016/j.healthplace.2009.06.002</a>
</div>
<div id="ref-luo03" class="csl-entry">
Luo, W., &amp; Wang, F. (2003). Measures of spatial accessibility to health care in a GIS environment: Synthesis and a case study in the chicago region. <em>Environment and Planning B: Planning and Design</em>, <em>30</em>(6), 865–884. <a href="https://doi.org/10.1068/b29120" class="external-link">https://doi.org/10.1068/b29120</a>
</div>
<div id="ref-wan12" class="csl-entry">
Wan, N., Zou, B., &amp; Sternberg, T. (2012). A three-step floating catchment area method for analyzing spatial access to health services. <em>International Journal of Geographical Information Science</em>, <em>26</em>(6), 1073–1089. <a href="https://doi.org/10.1080/13658816.2011.624987" class="external-link">https://doi.org/10.1080/13658816.2011.624987</a>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Biocomplexity Institute, Micah Iserman.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.1.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
